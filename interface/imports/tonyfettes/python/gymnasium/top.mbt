// Generated by `wit-bindgen` 0.30.0. DO NOT EDIT!

pub struct Discrete {
  id : UInt
  n : UInt
} derive(Show, Eq)

pub struct FrozenLake {
  id : UInt
  action_space : Discrete
  observation_space : Discrete
} derive(Show, Eq)

pub struct FrozenLakeInfo {
  prob : Double
} derive(Show, Eq)

pub struct LunarLander {
  id : UInt
  action_space : Discrete
} derive(Show, Eq)

pub fn discrete_sample(discrete : Discrete) -> UInt {
  let result : Int = wasmImportDiscreteSample(
    discrete.id.to_int(),
    discrete.n.to_int(),
  )
  return result.to_uint()
}

pub fn frozen_lake_make(
  render_mode : Bytes,
  is_slippery : Bool,
  desc : Array[Bytes]?
) -> FrozenLake {
  let cleanupList : Array[@ffi.Cleanup] = []
  let ignoreList : Array[@ffi.Any] = []
  let (lowered, lowered5, lowered6) = match desc {
    None => (0, 0, 0)
    Some(payload2) => {
      let address = @ffi.malloc(payload2.length() * 8)
      for index = 0; index < payload2.length(); index = index + 1 {
        let element3 : Bytes = payload2[index]
        let base4 = address + index * 8
        @ffi.store32(base4 + 4, element3.length())
        @ffi.store32(base4 + 0, @ffi.bytes2ptr(element3))
        ignoreList.push(element3)
      }
      cleanupList.push({ address, size: payload2.length() * 8, align: 4 })
      (1, address, payload2.length())
    }
  }
  let return_area = @ffi.malloc(20)
  wasmImportFrozenLakeMake(
    @ffi.bytes2ptr(render_mode),
    render_mode.length(),
    if is_slippery {
      1
    } else {
      0
    },
    lowered,
    lowered5,
    lowered6,
    return_area,
  )
  ignore(render_mode)
  @ffi.free(return_area)
  cleanupList.each(fn(cleanup) { @ffi.free(cleanup.address) })
  ignore(ignoreList)
  return FrozenLake::{
    id: @ffi.load32(return_area + 0).to_uint(),
    action_space: Discrete::{
      id: @ffi.load32(return_area + 4).to_uint(),
      n: @ffi.load32(return_area + 8).to_uint(),
    },
    observation_space: Discrete::{
      id: @ffi.load32(return_area + 12).to_uint(),
      n: @ffi.load32(return_area + 16).to_uint(),
    },
  }
}

pub fn frozen_lake_reset(
  env : FrozenLake,
  seed : UInt?
) -> (Int, FrozenLakeInfo) {
  let (lowered, lowered3) = match seed {
    None => (0, 0)
    Some(payload2) => (1, payload2.to_int())
  }
  let return_area = @ffi.malloc(16)
  wasmImportFrozenLakeReset(
    env.id.to_int(),
    env.action_space.id.to_int(),
    env.action_space.n.to_int(),
    env.observation_space.id.to_int(),
    env.observation_space.n.to_int(),
    lowered,
    lowered3,
    return_area,
  )
  @ffi.free(return_area)
  return (
    @ffi.load32(return_area + 0),
    FrozenLakeInfo::{ prob: @ffi.loadf64(return_area + 8) },
  )
}

pub fn frozen_lake_step(
  env : FrozenLake,
  action : UInt
) -> (Int, Double, Bool, FrozenLakeInfo) {
  let return_area = @ffi.malloc(32)
  wasmImportFrozenLakeStep(
    env.id.to_int(),
    env.action_space.id.to_int(),
    env.action_space.n.to_int(),
    env.observation_space.id.to_int(),
    env.observation_space.n.to_int(),
    action.to_int(),
    return_area,
  )
  @ffi.free(return_area)
  return (
    @ffi.load32(return_area + 0),
    @ffi.loadf64(return_area + 8),
    @ffi.load8_u(return_area + 16) != 0,
    FrozenLakeInfo::{ prob: @ffi.loadf64(return_area + 24) },
  )
}

pub fn lunar_lander_make(render_mode : Bytes) -> UInt {
  let result : Int = wasmImportLunarLanderMake(
    @ffi.bytes2ptr(render_mode),
    render_mode.length(),
  )
  ignore(render_mode)
  return result.to_uint()
}

pub fn lunar_lander_reset(
  env : LunarLander,
  seed : UInt?
) -> FixedArray[Double] {
  let (lowered, lowered3) = match seed {
    None => (0, 0)
    Some(payload2) => (1, payload2.to_int())
  }
  let return_area = @ffi.malloc(8)
  wasmImportLunarLanderReset(
    env.id.to_int(),
    env.action_space.id.to_int(),
    env.action_space.n.to_int(),
    lowered,
    lowered3,
    return_area,
  )
  let result = @ffi.ptr2double_array(@ffi.load32(return_area + 0))
  @ffi.free(return_area)
  return result
}

pub fn lunar_lander_step(
  env : LunarLander,
  action : UInt
) -> (FixedArray[Double], Double, Bool) {
  let return_area = @ffi.malloc(24)
  wasmImportLunarLanderStep(
    env.id.to_int(),
    env.action_space.id.to_int(),
    env.action_space.n.to_int(),
    action.to_int(),
    return_area,
  )
  let result = @ffi.ptr2double_array(@ffi.load32(return_area + 0))
  @ffi.free(return_area)
  return (
    result,
    @ffi.loadf64(return_area + 8),
    @ffi.load8_u(return_area + 16) != 0,
  )
}
