// Generated by `wit-bindgen` 0.30.0. DO NOT EDIT!

pub struct Discrete {
  id : UInt
  n : UInt
} derive(Show, Eq)

pub struct FrozenLake {
  id : UInt
  action_space : Discrete
  observation_space : Discrete
} derive(Show, Eq)

pub struct FrozenLakeInfo {
  prob : Double
} derive(Show, Eq)

pub struct LunarLander {
  id : UInt
  action_space : Discrete
} derive(Show, Eq)

pub fn discrete_sample(discrete : Discrete) -> UInt {
  let result : Int = wasmImportDiscreteSample(
    discrete.id.to_int(),
    discrete.n.to_int(),
  )
  return result.to_uint()
}

pub fn frozen_lake_make(render_mode : Bytes, is_slippery : Bool) -> FrozenLake {
  let return_area = @ffi.malloc(20)
  wasmImportFrozenLakeMake(
    @ffi.bytes2ptr(render_mode),
    render_mode.length(),
    if is_slippery {
      1
    } else {
      0
    },
    return_area,
  )
  ignore(render_mode)
  @ffi.free(return_area)
  return FrozenLake::{
    id: @ffi.load32(return_area + 0).to_uint(),
    action_space: Discrete::{
      id: @ffi.load32(return_area + 4).to_uint(),
      n: @ffi.load32(return_area + 8).to_uint(),
    },
    observation_space: Discrete::{
      id: @ffi.load32(return_area + 12).to_uint(),
      n: @ffi.load32(return_area + 16).to_uint(),
    },
  }
}

pub fn frozen_lake_reset(
  env : FrozenLake,
  seed : UInt?
) -> (Int, FrozenLakeInfo) {
  let (lowered, lowered3) = match seed {
    None => (0, 0)
    Some(payload2) => (1, payload2.to_int())
  }
  let return_area = @ffi.malloc(16)
  wasmImportFrozenLakeReset(
    env.id.to_int(),
    env.action_space.id.to_int(),
    env.action_space.n.to_int(),
    env.observation_space.id.to_int(),
    env.observation_space.n.to_int(),
    lowered,
    lowered3,
    return_area,
  )
  @ffi.free(return_area)
  return (
    @ffi.load32(return_area + 0),
    FrozenLakeInfo::{ prob: @ffi.loadf64(return_area + 8) },
  )
}

pub fn frozen_lake_step(
  env : FrozenLake,
  action : UInt
) -> (Int, Double, Bool, FrozenLakeInfo) {
  let return_area = @ffi.malloc(32)
  wasmImportFrozenLakeStep(
    env.id.to_int(),
    env.action_space.id.to_int(),
    env.action_space.n.to_int(),
    env.observation_space.id.to_int(),
    env.observation_space.n.to_int(),
    action.to_int(),
    return_area,
  )
  @ffi.free(return_area)
  return (
    @ffi.load32(return_area + 0),
    @ffi.loadf64(return_area + 8),
    @ffi.load8_u(return_area + 16) != 0,
    FrozenLakeInfo::{ prob: @ffi.loadf64(return_area + 24) },
  )
}

pub fn lunar_lander_make(render_mode : Bytes) -> UInt {
  let result : Int = wasmImportLunarLanderMake(
    @ffi.bytes2ptr(render_mode),
    render_mode.length(),
  )
  ignore(render_mode)
  return result.to_uint()
}

pub fn lunar_lander_reset(
  env : LunarLander,
  seed : UInt?
) -> FixedArray[Double] {
  let (lowered, lowered3) = match seed {
    None => (0, 0)
    Some(payload2) => (1, payload2.to_int())
  }
  let return_area = @ffi.malloc(8)
  wasmImportLunarLanderReset(
    env.id.to_int(),
    env.action_space.id.to_int(),
    env.action_space.n.to_int(),
    lowered,
    lowered3,
    return_area,
  )
  let result = @ffi.ptr2double_array(@ffi.load32(return_area + 0))
  @ffi.free(return_area)
  return result
}

pub fn lunar_lander_step(
  env : LunarLander,
  action : UInt
) -> (FixedArray[Double], Double, Bool) {
  let return_area = @ffi.malloc(24)
  wasmImportLunarLanderStep(
    env.id.to_int(),
    env.action_space.id.to_int(),
    env.action_space.n.to_int(),
    action.to_int(),
    return_area,
  )
  let result = @ffi.ptr2double_array(@ffi.load32(return_area + 0))
  @ffi.free(return_area)
  return (
    result,
    @ffi.loadf64(return_area + 8),
    @ffi.load8_u(return_area + 16) != 0,
  )
}
